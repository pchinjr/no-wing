/**
 * SAM Template Service - Generates Infrastructure as Code
 * This is the proper way to deploy AWS Lambda functions!
 */

import * as fs from 'fs';
import * as path from 'path';
import { QIdentity } from '../types';

export interface SAMTemplate {
  AWSTemplateFormatVersion: string;
  Transform: string;
  Description: string;
  Globals?: any;
  Parameters?: Record<string, any>;
  Resources: Record<string, any>;
  Outputs?: Record<string, any>;
}

export interface LambdaProjectStructure {
  projectPath: string;
  templatePath: string;
  codePath: string;
  functionName: string;
  apiEndpoint?: string;
}

export class SAMTemplateService {
  private workspaceDir: string;

  constructor(workspaceDir: string = './q-workspace') {
    this.workspaceDir = workspaceDir;
    this.ensureWorkspaceExists();
  }

  /**
   * Generate a complete SAM project for Lambda function
   */
  async generateLambdaProject(
    qIdentity: QIdentity,
    functionName: string,
    description: string,
    functionType: 'api' | 'processor' | 'auth' | 'webhook' = 'api'
  ): Promise<LambdaProjectStructure> {
    console.log(`üèóÔ∏è Generating SAM project: ${functionName}`);

    // Create project directory
    const projectName = `${functionName}-${Date.now()}`;
    const projectPath = path.join(this.workspaceDir, projectName);
    
    if (!fs.existsSync(projectPath)) {
      fs.mkdirSync(projectPath, { recursive: true });
    }

    // Create source directory
    const srcPath = path.join(projectPath, 'src');
    if (!fs.existsSync(srcPath)) {
      fs.mkdirSync(srcPath);
    }

    // Generate Lambda function code
    const functionCode = this.generateLambdaCode(functionType, functionName, description);
    const codePath = path.join(srcPath, 'index.js');
    fs.writeFileSync(codePath, functionCode);

    // Generate SAM template
    const samTemplate = this.generateSAMTemplate(functionName, description, functionType);
    const templatePath = path.join(projectPath, 'template.yaml');
    fs.writeFileSync(templatePath, this.templateToYAML(samTemplate));

    // Generate package.json
    const packageJson = this.generatePackageJson(functionName, description);
    fs.writeFileSync(path.join(projectPath, 'package.json'), JSON.stringify(packageJson, null, 2));

    // Generate README
    const readme = this.generateProjectReadme(functionName, description, functionType);
    fs.writeFileSync(path.join(projectPath, 'README.md'), readme);

    // Generate .gitignore
    const gitignore = this.generateGitignore();
    fs.writeFileSync(path.join(projectPath, '.gitignore'), gitignore);

    console.log(`‚úÖ Generated SAM project at: ${projectPath}`);

    return {
      projectPath,
      templatePath,
      codePath,
      functionName: this.getFunctionLogicalName(functionName)
    };
  }

  /**
   * Generate SAM template for Lambda function
   */
  private generateSAMTemplate(
    functionName: string,
    description: string,
    functionType: string
  ): SAMTemplate {
    const logicalName = this.getFunctionLogicalName(functionName);
    
    const template: SAMTemplate = {
      AWSTemplateFormatVersion: '2010-09-09',
      Transform: 'AWS::Serverless-2016-10-31',
      Description: `${description} - Generated by no-wing Q Agent`,
      
      Globals: {
        Function: {
          Runtime: 'nodejs18.x',
          Timeout: 30,
          MemorySize: 256,
          Environment: {
            Variables: {
              GENERATED_BY: 'no-wing-Q-Agent',
              FUNCTION_TYPE: functionType,
              DEPLOYMENT_TIME: new Date().toISOString()
            }
          },
          Tags: {
            CreatedBy: 'no-wing-Q-Agent',
            Purpose: 'AWS-Lambda-Hackathon',
            FunctionType: functionType
          }
        }
      },

      Resources: {}
    };

    // Add Lambda function resource
    template.Resources[logicalName] = {
      Type: 'AWS::Serverless::Function',
      Properties: {
        FunctionName: functionName,
        CodeUri: 'src/',
        Handler: 'index.handler',
        Description: description,
        Events: this.generateEvents(functionType, functionName)
      }
    };

    // Add outputs
    template.Outputs = {
      [`${logicalName}Arn`]: {
        Description: `ARN of the ${functionName} Lambda function`,
        Value: { Ref: logicalName }
      }
    };

    // Add API Gateway output if it's an API function
    if (functionType === 'api') {
      template.Outputs.ApiUrl = {
        Description: 'API Gateway endpoint URL',
        Value: {
          'Fn::Sub': `https://\${ServerlessRestApi}.execute-api.\${AWS::Region}.amazonaws.com/Prod/`
        }
      };
    }

    return template;
  }

  /**
   * Generate events based on function type
   */
  private generateEvents(functionType: string, functionName: string): Record<string, any> {
    switch (functionType) {
      case 'api':
        return {
          ApiEvent: {
            Type: 'Api',
            Properties: {
              Path: `/${functionName}`,
              Method: 'ANY'
            }
          }
        };

      case 'webhook':
        return {
          WebhookApi: {
            Type: 'Api',
            Properties: {
              Path: `/webhook/${functionName}`,
              Method: 'POST'
            }
          }
        };

      case 'processor':
        return {
          S3Event: {
            Type: 'S3',
            Properties: {
              Bucket: { Ref: 'ProcessingBucket' },
              Events: 's3:ObjectCreated:*',
              Filter: {
                S3Key: {
                  Rules: [
                    { Name: 'prefix', Value: 'uploads/' },
                    { Name: 'suffix', Value: '.json' }
                  ]
                }
              }
            }
          }
        };

      case 'auth':
        // Authorizer functions don't need events in SAM
        return {};

      default:
        return {
          ApiEvent: {
            Type: 'Api',
            Properties: {
              Path: `/${functionName}`,
              Method: 'GET'
            }
          }
        };
    }
  }

  /**
   * Generate Lambda function code
   */
  private generateLambdaCode(
    type: string,
    functionName: string,
    description: string
  ): string {
    const baseCode = `/**
 * ${description}
 * Generated by no-wing Q Agent using SAM/IaC
 * Function: ${functionName}
 * Type: ${type}
 */

const AWS = require('aws-sdk');

exports.handler = async (event, context) => {
    console.log('üöÄ Lambda function invoked:', {
        functionName: '${functionName}',
        type: '${type}',
        requestId: context.awsRequestId,
        event: JSON.stringify(event, null, 2)
    });
    
    try {`;

    switch (type) {
      case 'api':
        return baseCode + `
        // API Gateway Lambda function with SAM
        const httpMethod = event.httpMethod || 'GET';
        const path = event.path || '/';
        const queryParams = event.queryStringParameters || {};
        const body = event.body ? JSON.parse(event.body) : {};
        const headers = event.headers || {};
        
        console.log('üì° API Request:', { httpMethod, path, queryParams });
        
        let response;
        
        switch (httpMethod) {
            case 'GET':
                response = {
                    message: 'Hello from ${functionName}!',
                    description: '${description}',
                    timestamp: new Date().toISOString(),
                    path: path,
                    queryParams: queryParams,
                    generatedBy: 'no-wing-Q-Agent-SAM',
                    deployedWith: 'AWS-SAM-IaC'
                };
                break;
                
            case 'POST':
                response = {
                    message: 'Data received and processed',
                    receivedData: body,
                    processedAt: new Date().toISOString(),
                    functionName: '${functionName}',
                    generatedBy: 'no-wing-Q-Agent-SAM'
                };
                break;
                
            case 'PUT':
                response = {
                    message: 'Resource updated successfully',
                    updatedData: body,
                    updatedAt: new Date().toISOString(),
                    functionName: '${functionName}'
                };
                break;
                
            case 'DELETE':
                response = {
                    message: 'Resource deleted successfully',
                    deletedAt: new Date().toISOString(),
                    functionName: '${functionName}'
                };
                break;
                
            default:
                response = {
                    message: 'Method not supported',
                    supportedMethods: ['GET', 'POST', 'PUT', 'DELETE'],
                    receivedMethod: httpMethod
                };
        }
        
        return {
            statusCode: 200,
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type,Authorization',
                'X-Generated-By': 'no-wing-Q-Agent',
                'X-Deployed-With': 'AWS-SAM'
            },
            body: JSON.stringify(response, null, 2)
        };
        
    } catch (error) {
        console.error('‚ùå Error in ${functionName}:', error);
        
        return {
            statusCode: 500,
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            body: JSON.stringify({
                error: 'Internal server error',
                message: error.message,
                functionName: '${functionName}',
                timestamp: new Date().toISOString(),
                generatedBy: 'no-wing-Q-Agent'
            })
        };
    }
};`;

      case 'auth':
        return baseCode + `
        // Lambda Authorizer function with SAM
        const token = event.authorizationToken;
        const methodArn = event.methodArn;
        
        console.log('üîê Authorization request:', { 
            token: token ? 'present' : 'missing',
            methodArn 
        });
        
        // Simple token validation (in production, use JWT/OAuth)
        const isValidToken = token && 
                           token.startsWith('Bearer ') && 
                           token.length > 20;
        
        const principalId = isValidToken ? 'user-' + Date.now() : 'unauthorized';
        
        const policy = {
            principalId: principalId,
            policyDocument: {
                Version: '2012-10-17',
                Statement: [{
                    Action: 'execute-api:Invoke',
                    Effect: isValidToken ? 'Allow' : 'Deny',
                    Resource: methodArn
                }]
            },
            context: {
                functionName: '${functionName}',
                validatedAt: new Date().toISOString(),
                generatedBy: 'no-wing-Q-Agent-SAM',
                tokenValid: isValidToken.toString()
            }
        };
        
        console.log('üîê Auth result:', { 
            principalId: policy.principalId,
            effect: policy.policyDocument.Statement[0].Effect 
        });
        
        return policy;
        
    } catch (error) {
        console.error('‚ùå Auth error:', error);
        throw new Error('Unauthorized');
    }
};`;

      case 'processor':
        return baseCode + `
        // Data processing Lambda function with SAM
        const records = event.Records || [];
        const results = [];
        
        console.log('üìù Processing records:', records.length);
        
        for (const record of records) {
            console.log('üìÑ Processing record:', record.eventSource);
            
            let processedData;
            
            if (record.eventSource === 'aws:s3') {
                // S3 event processing
                const bucket = record.s3.bucket.name;
                const key = decodeURIComponent(record.s3.object.key.replace(/\+/g, ' '));
                
                processedData = {
                    eventType: 'S3ObjectCreated',
                    bucket: bucket,
                    key: key,
                    size: record.s3.object.size,
                    eventName: record.eventName,
                    processedAt: new Date().toISOString(),
                    functionName: '${functionName}',
                    generatedBy: 'no-wing-Q-Agent-SAM'
                };
                
                // Here you could process the S3 object
                console.log('üì¶ S3 Object:', { bucket, key });
                
            } else if (record.eventSource === 'aws:dynamodb') {
                // DynamoDB stream processing
                processedData = {
                    eventType: 'DynamoDBStreamRecord',
                    eventName: record.eventName,
                    dynamodb: record.dynamodb,
                    processedAt: new Date().toISOString(),
                    functionName: '${functionName}',
                    generatedBy: 'no-wing-Q-Agent-SAM'
                };
                
            } else {
                // Generic event processing
                processedData = {
                    eventType: 'GenericEvent',
                    eventSource: record.eventSource,
                    data: record,
                    processedAt: new Date().toISOString(),
                    functionName: '${functionName}',
                    generatedBy: 'no-wing-Q-Agent-SAM'
                };
            }
            
            results.push(processedData);
            console.log('‚úÖ Processed:', processedData.eventType);
        }
        
        const summary = {
            statusCode: 200,
            processedRecords: results.length,
            results: results,
            functionName: '${functionName}',
            generatedBy: 'no-wing-Q-Agent-SAM',
            completedAt: new Date().toISOString()
        };
        
        console.log('üìä Processing summary:', { 
            totalRecords: records.length,
            processedRecords: results.length 
        });
        
        return summary;
        
    } catch (error) {
        console.error('‚ùå Processing error:', error);
        throw error;
    }
};`;

      case 'webhook':
        return baseCode + `
        // Webhook Lambda function with SAM
        const headers = event.headers || {};
        const body = event.body ? JSON.parse(event.body) : {};
        const sourceIP = event.requestContext?.identity?.sourceIp || 'unknown';
        
        console.log('üîó Webhook received:', {
            source: headers['user-agent'] || 'unknown',
            sourceIP: sourceIP,
            contentType: headers['content-type'],
            bodySize: event.body ? event.body.length : 0
        });
        
        // Webhook signature validation (simplified)
        const signature = headers['x-webhook-signature'] || 
                         headers['X-Webhook-Signature'] ||
                         headers['x-hub-signature'];
        
        // Process webhook payload
        const response = {
            message: 'Webhook processed successfully',
            receivedAt: new Date().toISOString(),
            payload: body,
            metadata: {
                sourceIP: sourceIP,
                userAgent: headers['user-agent'],
                signature: signature ? 'present' : 'missing',
                contentType: headers['content-type']
            },
            functionName: '${functionName}',
            generatedBy: 'no-wing-Q-Agent-SAM'
        };
        
        // In production, you might:
        // - Validate webhook signatures
        // - Send to SQS/SNS for processing
        // - Store in DynamoDB
        // - Trigger other Lambda functions
        
        console.log('üì§ Webhook response prepared');
        
        return {
            statusCode: 200,
            headers: {
                'Content-Type': 'application/json',
                'X-Generated-By': 'no-wing-Q-Agent',
                'X-Deployed-With': 'AWS-SAM'
            },
            body: JSON.stringify(response, null, 2)
        };
        
    } catch (error) {
        console.error('‚ùå Webhook error:', error);
        
        return {
            statusCode: 500,
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                error: 'Webhook processing failed',
                message: error.message,
                timestamp: new Date().toISOString(),
                functionName: '${functionName}'
            })
        };
    }
};`;

      default:
        return baseCode + `
        // Generic Lambda function with SAM
        const response = {
            message: 'Hello from ${functionName}!',
            description: '${description}',
            event: event,
            timestamp: new Date().toISOString(),
            generatedBy: 'no-wing-Q-Agent-SAM',
            deployedWith: 'AWS-SAM-IaC'
        };
        
        console.log('üì§ Response prepared:', response.message);
        
        return {
            statusCode: 200,
            body: JSON.stringify(response, null, 2)
        };
        
    } catch (error) {
        console.error('‚ùå Error:', error);
        throw error;
    }
};`;
    }
  }

  /**
   * Generate package.json for the Lambda project
   */
  private generatePackageJson(functionName: string, description: string): any {
    return {
      name: functionName,
      version: "1.0.0",
      description: description,
      main: "src/index.js",
      scripts: {
        "build": "sam build",
        "deploy": "sam deploy --guided",
        "deploy-fast": "sam build && sam deploy",
        "local": "sam local start-api",
        "invoke": `sam local invoke ${this.getFunctionLogicalName(functionName)}`,
        "logs": "sam logs --tail",
        "delete": "sam delete"
      },
      keywords: [
        "aws",
        "lambda",
        "serverless",
        "sam",
        "iac",
        "no-wing",
        "q-agent"
      ],
      author: "no-wing Q Agent",
      license: "MIT",
      devDependencies: {},
      dependencies: {
        "aws-sdk": "^2.1000.0"
      }
    };
  }

  /**
   * Generate project README
   */
  private generateProjectReadme(
    functionName: string,
    description: string,
    functionType: string
  ): string {
    return `# ${functionName}

${description}

**Generated by no-wing Q Agent using AWS SAM and Infrastructure as Code**

## üöÄ Quick Deploy

\`\`\`bash
# Build and deploy
sam build && sam deploy --guided

# For subsequent deployments
sam build && sam deploy
\`\`\`

## üß™ Local Testing

\`\`\`bash
# Start local API
sam local start-api

# Test the endpoint
curl http://localhost:3000/${functionName}

# Invoke function directly
sam local invoke ${this.getFunctionLogicalName(functionName)}
\`\`\`

## üìÅ Project Structure

\`\`\`
${functionName}/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ index.js          # Lambda function code
‚îú‚îÄ‚îÄ template.yaml         # SAM template (IaC)
‚îú‚îÄ‚îÄ package.json          # Project configuration
‚îî‚îÄ‚îÄ README.md            # This file
\`\`\`

## üèóÔ∏è Infrastructure as Code

This project uses AWS SAM (Serverless Application Model) for Infrastructure as Code:

- **template.yaml**: Defines all AWS resources
- **Automatic API Gateway**: ${functionType === 'api' ? 'Configured' : 'Not applicable'}
- **IAM Roles**: Automatically created with least privilege
- **CloudWatch Logs**: Automatically configured

## üîß Function Details

- **Type**: ${functionType}
- **Runtime**: Node.js 18.x
- **Memory**: 256 MB
- **Timeout**: 30 seconds
- **Generated by**: no-wing Q Agent

## üìä Monitoring

After deployment, monitor your function:

\`\`\`bash
# View logs
sam logs --tail

# View in AWS Console
aws lambda get-function --function-name ${functionName}
\`\`\`

## üóëÔ∏è Cleanup

To delete all resources:

\`\`\`bash
sam delete
\`\`\`

---

**Created with ‚ù§Ô∏è by no-wing Q Agent using AWS SAM and Infrastructure as Code**
`;
  }

  /**
   * Generate .gitignore for Lambda project
   */
  private generateGitignore(): string {
    return `# SAM build artifacts
.aws-sam/
samconfig.toml

# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Coverage
coverage/
*.lcov
`;
  }

  /**
   * Convert SAM template object to YAML string
   */
  private templateToYAML(template: SAMTemplate): string {
    // Simple YAML conversion - in production, use a proper YAML library
    const yaml = require('js-yaml');
    return yaml.dump(template, {
      indent: 2,
      lineWidth: 120,
      noRefs: true
    });
  }

  /**
   * Get CloudFormation logical name for function
   */
  private getFunctionLogicalName(functionName: string): string {
    return functionName
      .split('-')
      .map(part => part.charAt(0).toUpperCase() + part.slice(1))
      .join('') + 'Function';
  }

  /**
   * Ensure workspace directory exists
   */
  private ensureWorkspaceExists(): void {
    if (!fs.existsSync(this.workspaceDir)) {
      fs.mkdirSync(this.workspaceDir, { recursive: true });
    }
  }
}
