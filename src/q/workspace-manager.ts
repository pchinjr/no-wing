import { mkdirSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';
import { QIdentity } from './identity';

export interface WorkspaceConfig {
  name: string;
  description: string;
  qIdentity: QIdentity;
  environment: string;
  region: string;
}

export interface GeneratedProject {
  name: string;
  path: string;
  files: Array<{
    path: string;
    content: string;
    type: 'code' | 'config' | 'iac' | 'docs';
  }>;
  infrastructure: {
    samTemplate: string;
    parameters: Record<string, any>;
  };
}

export class QWorkspaceManager {
  private workspaceRoot: string;

  constructor(workspaceRoot: string = './q-workspace') {
    this.workspaceRoot = workspaceRoot;
    this.ensureWorkspaceExists();
  }

  private ensureWorkspaceExists(): void {
    if (!existsSync(this.workspaceRoot)) {
      mkdirSync(this.workspaceRoot, { recursive: true });
      
      // Create workspace structure
      mkdirSync(join(this.workspaceRoot, 'projects'), { recursive: true });
      mkdirSync(join(this.workspaceRoot, 'templates'), { recursive: true });
      mkdirSync(join(this.workspaceRoot, 'deployments'), { recursive: true });
      
      // Create workspace README
      this.createWorkspaceReadme();
    }
  }

  private createWorkspaceReadme(): void {
    const readmeContent = `# Q Workspace

This directory contains all code and infrastructure generated by Q, your AI development teammate.

## Structure

\`\`\`
q-workspace/
â”œâ”€â”€ projects/           # Generated application code
â”‚   â”œâ”€â”€ lambda-auth/    # Example: Authentication service
â”‚   â”œâ”€â”€ data-pipeline/  # Example: Data processing pipeline
â”‚   â””â”€â”€ api-gateway/    # Example: API Gateway setup
â”œâ”€â”€ templates/          # SAM templates for infrastructure
â”œâ”€â”€ deployments/        # Deployment artifacts and logs
â””â”€â”€ README.md          # This file
\`\`\`

## Generated by Q

Each project in this workspace was created by Q based on your natural language requests.
All code includes:

- âœ… Working application code
- âœ… SAM infrastructure templates  
- âœ… Deployment configurations
- âœ… Documentation and README files
- âœ… Git history with Q's commits

## Usage

Each project can be deployed independently:

\`\`\`bash
cd projects/lambda-auth
sam build && sam deploy --guided
\`\`\`

Or use no-wing to manage deployments:

\`\`\`bash
no-wing deploy lambda-auth --env dev
\`\`\`
`;

    writeFileSync(join(this.workspaceRoot, 'README.md'), readmeContent);
  }

  async createProject(config: WorkspaceConfig, projectType: string): Promise<GeneratedProject> {
    const projectName = this.sanitizeProjectName(config.name);
    const projectPath = join(this.workspaceRoot, 'projects', projectName);
    
    // Create project directory
    mkdirSync(projectPath, { recursive: true });
    mkdirSync(join(projectPath, 'src'), { recursive: true });
    mkdirSync(join(projectPath, 'tests'), { recursive: true });
    mkdirSync(join(projectPath, 'docs'), { recursive: true });

    const project: GeneratedProject = {
      name: projectName,
      path: projectPath,
      files: [],
      infrastructure: {
        samTemplate: '',
        parameters: {}
      }
    };

    // Generate project based on type
    switch (projectType) {
      case 'lambda':
        await this.generateLambdaProject(project, config);
        break;
      case 'api':
        await this.generateApiProject(project, config);
        break;
      case 's3-processor':
        await this.generateS3ProcessorProject(project, config);
        break;
      default:
        await this.generateGenericProject(project, config);
    }

    // Write all files
    project.files.forEach(file => {
      const fullPath = join(projectPath, file.path);
      const dir = fullPath.substring(0, fullPath.lastIndexOf('/'));
      mkdirSync(dir, { recursive: true });
      writeFileSync(fullPath, file.content);
    });

    return project;
  }

  private async generateLambdaProject(project: GeneratedProject, config: WorkspaceConfig): Promise<void> {
    // Lambda function code
    project.files.push({
      path: 'src/index.js',
      type: 'code',
      content: this.generateLambdaCode(config)
    });

    // SAM template
    project.files.push({
      path: 'template.yaml',
      type: 'iac',
      content: this.generateLambdaSamTemplate(config)
    });

    // Package.json
    project.files.push({
      path: 'package.json',
      type: 'config',
      content: this.generatePackageJson(config)
    });

    // README
    project.files.push({
      path: 'README.md',
      type: 'docs',
      content: this.generateProjectReadme(config, 'Lambda Function')
    });

    // Tests
    project.files.push({
      path: 'tests/index.test.js',
      type: 'code',
      content: this.generateLambdaTests(config)
    });

    project.infrastructure = {
      samTemplate: 'template.yaml',
      parameters: {
        FunctionName: config.name,
        Environment: config.environment,
        QIdentity: config.qIdentity.id
      }
    };
  }

  private async generateApiProject(project: GeneratedProject, config: WorkspaceConfig): Promise<void> {
    // API Gateway + Lambda
    project.files.push({
      path: 'src/api.js',
      type: 'code',
      content: this.generateApiCode(config)
    });

    project.files.push({
      path: 'template.yaml',
      type: 'iac',
      content: this.generateApiSamTemplate(config)
    });

    project.files.push({
      path: 'README.md',
      type: 'docs',
      content: this.generateProjectReadme(config, 'API Gateway + Lambda')
    });
  }

  private async generateS3ProcessorProject(project: GeneratedProject, config: WorkspaceConfig): Promise<void> {
    // S3 + Lambda processor
    project.files.push({
      path: 'src/processor.js',
      type: 'code',
      content: this.generateS3ProcessorCode(config)
    });

    project.files.push({
      path: 'template.yaml',
      type: 'iac',
      content: this.generateS3ProcessorSamTemplate(config)
    });

    project.files.push({
      path: 'README.md',
      type: 'docs',
      content: this.generateProjectReadme(config, 'S3 Event Processor')
    });
  }

  private async generateGenericProject(project: GeneratedProject, config: WorkspaceConfig): Promise<void> {
    project.files.push({
      path: 'src/index.js',
      type: 'code',
      content: this.generateGenericCode(config)
    });

    project.files.push({
      path: 'README.md',
      type: 'docs',
      content: this.generateProjectReadme(config, 'Generic Project')
    });
  }

  private generateLambdaCode(config: WorkspaceConfig): string {
    return `/**
 * ${config.description}
 * Generated by Q (${config.qIdentity.id})
 * Environment: ${config.environment}
 */

exports.handler = async (event, context) => {
    console.log('ðŸš€ Lambda function invoked');
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        // TODO: Implement your business logic here
        const result = {
            message: 'Hello from ${config.name}!',
            timestamp: new Date().toISOString(),
            environment: '${config.environment}',
            requestId: context.awsRequestId,
            generatedBy: 'Q-${config.qIdentity.id}'
        };
        
        return {
            statusCode: 200,
            headers: {
                'Content-Type': 'application/json',
                'X-Generated-By': 'Q-AI-Agent'
            },
            body: JSON.stringify(result)
        };
        
    } catch (error) {
        console.error('âŒ Error:', error);
        
        return {
            statusCode: 500,
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                error: 'Internal server error',
                message: error.message,
                timestamp: new Date().toISOString()
            })
        };
    }
};`;
  }

  private generateLambdaSamTemplate(config: WorkspaceConfig): string {
    return `AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: '${config.description} - Generated by Q'

Parameters:
  Environment:
    Type: String
    Default: ${config.environment}
    AllowedValues: [dev, staging, prod]
  
  FunctionName:
    Type: String
    Default: ${config.name}

Globals:
  Function:
    Timeout: 30
    MemorySize: 256
    Runtime: nodejs18.x
    Environment:
      Variables:
        ENVIRONMENT: !Ref Environment
        GENERATED_BY: Q-${config.qIdentity.id}

Resources:
  ${this.toPascalCase(config.name)}Function:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub '\${FunctionName}-\${Environment}'
      CodeUri: src/
      Handler: index.handler
      Description: ${config.description}
      Tags:
        GeneratedBy: Q-AI-Agent
        Environment: !Ref Environment
        QIdentity: ${config.qIdentity.id}

Outputs:
  FunctionName:
    Description: Lambda Function Name
    Value: !Ref ${this.toPascalCase(config.name)}Function
    Export:
      Name: !Sub '\${AWS::StackName}-FunctionName'
  
  FunctionArn:
    Description: Lambda Function ARN
    Value: !GetAtt ${this.toPascalCase(config.name)}Function.Arn
    Export:
      Name: !Sub '\${AWS::StackName}-FunctionArn'`;
  }

  private generatePackageJson(config: WorkspaceConfig): string {
    return JSON.stringify({
      name: config.name,
      version: "1.0.0",
      description: config.description,
      main: "src/index.js",
      scripts: {
        test: "jest",
        "test:watch": "jest --watch",
        build: "sam build",
        deploy: "sam deploy --guided",
        "deploy:dev": "sam deploy --parameter-overrides Environment=dev",
        "deploy:staging": "sam deploy --parameter-overrides Environment=staging",
        "deploy:prod": "sam deploy --parameter-overrides Environment=prod",
        logs: "sam logs --tail"
      },
      keywords: ["aws", "lambda", "serverless", "q-generated"],
      author: `Q AI Agent (${config.qIdentity.id})`,
      license: "MIT",
      devDependencies: {
        jest: "^29.0.0",
        "@types/aws-lambda": "^8.10.0"
      },
      generatedBy: {
        agent: "Q",
        identity: config.qIdentity.id,
        timestamp: new Date().toISOString(),
        noWingVersion: "1.0.0"
      }
    }, null, 2);
  }

  private generateProjectReadme(config: WorkspaceConfig, projectType: string): string {
    return `# ${config.name}

${config.description}

**Generated by Q AI Agent** - ${config.qIdentity.id}

## Project Type
${projectType}

## Environment
${config.environment}

## Deployment

### Quick Deploy
\`\`\`bash
sam build && sam deploy --guided
\`\`\`

### Environment-specific Deploy
\`\`\`bash
npm run deploy:${config.environment}
\`\`\`

### Using no-wing
\`\`\`bash
no-wing deploy ${config.name} --env ${config.environment}
\`\`\`

## Testing
\`\`\`bash
npm test
\`\`\`

## Monitoring
\`\`\`bash
npm run logs
\`\`\`

## Generated Files
- \`src/\` - Application source code
- \`template.yaml\` - SAM infrastructure template
- \`tests/\` - Unit tests
- \`package.json\` - Node.js configuration

## Q Agent Info
- **Identity**: ${config.qIdentity.id}
- **Level**: ${config.qIdentity.level}
- **Generated**: ${new Date().toISOString()}

---
*This project was created by Q, your AI development teammate. ðŸ›«*`;
  }

  private generateLambdaTests(config: WorkspaceConfig): string {
    return `/**
 * Tests for ${config.name}
 * Generated by Q (${config.qIdentity.id})
 */

const { handler } = require('../src/index');

describe('${config.name}', () => {
    test('should return success response', async () => {
        const event = {
            httpMethod: 'GET',
            path: '/test'
        };
        
        const context = {
            awsRequestId: 'test-request-id'
        };
        
        const result = await handler(event, context);
        
        expect(result.statusCode).toBe(200);
        expect(result.headers['Content-Type']).toBe('application/json');
        
        const body = JSON.parse(result.body);
        expect(body.message).toContain('${config.name}');
        expect(body.generatedBy).toBe('Q-${config.qIdentity.id}');
    });
    
    test('should handle errors gracefully', async () => {
        // Test error handling
        const event = null; // This should cause an error
        const context = { awsRequestId: 'test-error' };
        
        const result = await handler(event, context);
        
        expect(result.statusCode).toBe(500);
        expect(result.headers['Content-Type']).toBe('application/json');
    });
});`;
  }

  private generateApiCode(config: WorkspaceConfig): string {
    return `// API Gateway + Lambda implementation
// Generated by Q (${config.qIdentity.id})
// TODO: Implement API endpoints`;
  }

  private generateApiSamTemplate(config: WorkspaceConfig): string {
    return `# API Gateway SAM template
# Generated by Q (${config.qIdentity.id})
# TODO: Implement API Gateway template`;
  }

  private generateS3ProcessorCode(config: WorkspaceConfig): string {
    return `// S3 Event Processor
// Generated by Q (${config.qIdentity.id})
// TODO: Implement S3 event processing`;
  }

  private generateS3ProcessorSamTemplate(config: WorkspaceConfig): string {
    return `# S3 + Lambda SAM template
# Generated by Q (${config.qIdentity.id})
# TODO: Implement S3 processor template`;
  }

  private generateGenericCode(config: WorkspaceConfig): string {
    return `// ${config.description}
// Generated by Q (${config.qIdentity.id})
console.log('Hello from ${config.name}!');`;
  }

  private sanitizeProjectName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  private toPascalCase(str: string): string {
    return str
      .split(/[-_\s]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  getWorkspaceRoot(): string {
    return this.workspaceRoot;
  }

  listProjects(): string[] {
    const projectsDir = join(this.workspaceRoot, 'projects');
    if (!existsSync(projectsDir)) {
      return [];
    }
    
    const { readdirSync, statSync } = require('fs');
    return readdirSync(projectsDir)
      .filter((item: string) => statSync(join(projectsDir, item)).isDirectory());
  }
}
